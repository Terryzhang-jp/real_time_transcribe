<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时语音转写和翻译</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f5f5f5;
        }

        h1, h2 {
            margin-bottom: 15px;
            color: #333;
        }

        .control-panel {
            margin: 20px 0;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        select, button {
            padding: 8px 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            outline: none;
        }

        select {
            background-color: #fff;
            min-width: 120px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-1px);
        }

        .status-panel {
            margin: 20px 0;
            padding: 15px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .status-panel p {
            margin: 5px 0;
            color: #666;
        }

        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 10px;
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .visualizer-container {
            margin: 20px 0;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        canvas {
            width: 100%;
            max-width: 800px;
            height: 150px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 10px 0;
            background: #fff;
        }

        .result-container {
            margin: 20px 0;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #queue-status {
            margin: 20px 0;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .progress-container {
            margin-top: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        #process-progress {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease-in-out;
        }

        #error-message {
            color: #dc3545;
            margin-top: 10px;
            padding: 10px;
            background: #fff;
            border-radius: 4px;
            display: none;
        }

        .transcription, .translation {
            margin: 15px 0;
            padding: 15px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 100px;
            color: #333;
            word-wrap: break-word;
            overflow-y: auto;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        #graph-container {
            margin: 20px 0;
            padding: 15px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #logic-graph {
            max-width: 100%;
            height: auto;
            margin: 10px 0;
        }

        #graph-details {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 0.9em;
            color: #666;
        }

        .debug-panel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div id="connection-status">
        连接状态: <span id="connection-status-text">未连接</span>
    </div>

    <div class="debug-panel" id="debug-panel">
        <div>Debug Information</div>
        <pre id="debug-info"></pre>
    </div>

    <h1>实时语音转写和翻译</h1>

    <div class="control-panel">
        <select id="languageSelect">
            <option value="">请选择语言</option>
            <option value="zh">中文</option>
            <option value="en">英语</option>
            <option value="ja">日语</option>
        </select>
        <button id="startButton" disabled>开始</button>
        <button id="stopButton" disabled>停止</button>
        <button id="clearButton">清除结果</button>
        <button id="toggleDebug">调试信息</button>
    </div>

    <div class="status-panel">
        <p id="status">未检测到人声</p>
        <p id="frequency">主要频率: - Hz</p>
        <p id="continuity">语音连续性: -</p>
        <p id="volume">当前音量: - dB</p>
    </div>

    <div id="queue-status">
        <h3>处理状态</h3>
        <p>当前处理：<span id="current-processing">无</span></p>
        <p>等待处理：<span id="queue-size">0</span> 个片段</p>
        <p>已处理总数：<span id="total-processed">0</span> 个片段</p>
        <div class="progress-container">
            <div class="progress-bar">
                <div id="process-progress"></div>
            </div>
        </div>
        <p id="error-message"></p>
    </div>

    <div class="visualizer-container">
        <h2>声音可视化</h2>
        <canvas id="frequencyVisualizer"></canvas>
        <canvas id="continuityVisualizer"></canvas>
        <canvas id="volumeVisualizer"></canvas>
    </div>

    <div class="result-container">
        <h2>转写结果：</h2>
        <div id="transcription" class="transcription"></div>

        <h2>翻译结果（中文）：</h2>
        <div id="translation" class="translation"></div>

        <h2>GPT-4 修正结果：</h2>
        <div id="corrected-text" class="transcription"></div>
    </div>

    <div id="graph-container">
        <h2>实时逻辑流程图：</h2>
        <img id="logic-graph" src="" alt="逻辑流程图" style="display: none; max-width: 100%; height: auto;">
        <div id="graph-status">等待语音输入...</div>
        <div id="graph-details">
            上次更新: <span id="last-update-time">从未更新</span><br>
            当前状态: <span id="current-status">初始化</span><br>
            错误信息: <span id="error-message-graph"></span>
        </div>
    </div>

    <div class="status-panel">
        <div class="status-item">
            <label>当前处理：</label>
            <span id="processing-status">无</span>
        </div>
        <div class="status-item">
            <label>等待处理：</label>
            <span id="queue-size">0</span> 个片段
        </div>
        <div class="status-item">
            <label>已处理总数：</label>
            <span id="total-processed">0</span> 个片段
        </div>
        <div class="progress-bar">
            <div id="process-progress" style="width: 0%"></div>
        </div>
    </div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        let isListening = false;
        let mediaRecorder;
        let audioChunks = [];
        let transcriptionBuffer = '';
        let translationBuffer = '';
        const socket = io({
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 1000,
            timeout: 60000,
            transports: ['websocket', 'polling']
        });

        // Debug functionality
        const debugPanel = document.getElementById('debug-panel');
        const debugInfo = document.getElementById('debug-info');
        document.getElementById('toggleDebug').onclick = () => {
            debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
        };

        function updateDebugInfo(info) {
            debugInfo.textContent = JSON.stringify(info, null, 2);
        }

        // 常量定义
        const VOLUME_THRESHOLD = -50;
        const NOISE_THRESHOLD = -70;
        const MIN_HUMAN_FREQ = 85;
        const MAX_HUMAN_FREQ = 255;
        const CONTINUITY_THRESHOLD = 500;
        const RECORDING_INTERVAL = 5000;

        // DOM元素
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const clearButton = document.getElementById('clearButton');
        const languageSelect = document.getElementById('languageSelect');
        const status = document.getElementById('status');
        const frequencyDisplay = document.getElementById('frequency');
        const continuityDisplay = document.getElementById('continuity');
        const volumeDisplay = document.getElementById('volume');

        // Canvas相关
        const frequencyCanvas = document.getElementById('frequencyVisualizer');
        const frequencyCtx = frequencyCanvas.getContext('2d');
        const continuityCanvas = document.getElementById('continuityVisualizer');
        const continuityCtx = continuityCanvas.getContext('2d');
        const volumeCanvas = document.getElementById('volumeVisualizer');
        const volumeCtx = volumeCanvas.getContext('2d');

        // 状态变量
        let lastVoiceDetectionTime = 0;
        let continuityBuffer = new Array(300).fill(0);
        let selectedLanguage = '';

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connection-status-text');
            statusElement.textContent = status;
            statusElement.style.color = status === '已连接' ? '#4CAF50' : '#dc3545';
        }

        // Socket.IO event handlers
        socket.on('connect', () => {
            console.log('WebSocket connected');
            updateConnectionStatus('已连接');
            document.getElementById('graph-status').textContent = '图表服务已连接';
        });

        socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
            updateConnectionStatus('已开');
            document.getElementById('graph-status').textContent = '图表服务已断开';
        });

        socket.on('connect_error', (error) => {
            console.error('WebSocket connection error:', error);
            updateConnectionStatus('连接错误');
            showError('WebSocket连接错误');
        });

        socket.on('transcription_result', (data) => {
            console.log('收到转写结果:', data);
            
            if (data.result) {
                const transcriptionDiv = document.getElementById('transcription');
                const translationDiv = document.getElementById('translation');
                const correctedDiv = document.getElementById('corrected-text');
                
                try {
                    // 添加新的转写文本
                    if (data.result.transcription) {
                        if (transcriptionDiv.textContent) {
                            transcriptionDiv.textContent += '\n' + data.result.transcription;
                        } else {
                            transcriptionDiv.textContent = data.result.transcription;
                        }
                    }
                    
                    // 添加新的翻译文本
                    if (data.result.translation) {
                        if (translationDiv.textContent) {
                            translationDiv.textContent += '\n' + data.result.translation;
                        } else {
                            translationDiv.textContent = data.result.translation;
                        }
                    }
                    
                    // 更新完整的修正文本
                    if (data.result.corrected_text) {
                        correctedDiv.textContent = data.result.corrected_text;
                    }
                    
                    // 自动滚动到底部
                    transcriptionDiv.scrollTop = transcriptionDiv.scrollHeight;
                    translationDiv.scrollTop = translationDiv.scrollHeight;
                    correctedDiv.scrollTop = correctedDiv.scrollHeight;
                    
                } catch (error) {
                    console.error('Error updating results:', error);
                }
            }
        });

        // Language selection
        languageSelect.onchange = () => {
            selectedLanguage = languageSelect.value;
            startButton.disabled = !selectedLanguage;
        };

        // Start recording
        startButton.onclick = async () => {
            if (!selectedLanguage) {
                alert('请先选择语言');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                setupAudioContext(stream);
                setupMediaRecorder(stream);
                
                isListening = true;
                detectSound();

                startButton.disabled = true;
                stopButton.disabled = false;
            } catch (error) {
                console.error('Error accessing microphone:', error);
                showError('无法访问麦克风，请检查权限设置。');
            }
        };

        // Stop recording
        stopButton.onclick = () => {
            stopRecording();
        };

        // Clear results
        clearButton.onclick = () => {
            clearResults();
        };

        function setupAudioContext(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            microphone = audioContext.createMediaStreamSource(stream);

            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.8;
            microphone.connect(analyser);
        }

        function setupMediaRecorder(stream) {
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                if (audioChunks.length > 0) {
                    sendAudioToServer();
                }
                if (isListening) {
                    startNewRecording();
                }
            };

            startNewRecording();
        }

        function startNewRecording() {
            audioChunks = [];
            mediaRecorder.start();
            setTimeout(() => {
                if (mediaRecorder.state === "recording") {
                    mediaRecorder.stop();
                }
            }, RECORDING_INTERVAL);
        }

        function stopRecording() {
            isListening = false;
            if (audioContext) {
                audioContext.close();
            }
            if (mediaRecorder) {
                mediaRecorder.stop();
            }
            resetUI();
        }

        function resetUI() {
            startButton.disabled = false;
            stopButton.disabled = true;
            status.textContent = '未检测到人声';
            frequencyDisplay.textContent = '主要频率: - Hz';
            continuityDisplay.textContent = '语音连续性: -';
            volumeDisplay.textContent = '当前音量: - dB';
        }

        function sendAudioToServer() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            console.log('Sending audio blob:', audioBlob.size, 'bytes');
            
            const formData = new FormData();
            formData.append('audio', audioBlob);
            formData.append('language', selectedLanguage);

            fetch('/transcribe', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server response:', data);
                updateDebugInfo({ event: 'audio_upload', response: data });
                
                if (data.error) {
                    showError(data.error);
                } else {
                    updateQueueStatus(data.queue_status);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showError('服务器通信错误');
            });
        }

        function detectSound() {
            if (!isListening) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Float32Array(bufferLength);
            analyser.getFloatFrequencyData(dataArray);

            const nyquist = audioContext.sampleRate / 2;
            const minIndex = Math.floor(MIN_HUMAN_FREQ * bufferLength / nyquist);
            const maxIndex = Math.ceil(MAX_HUMAN_FREQ * bufferLength / nyquist);

            let maxVolume = -Infinity;
            let maxFrequency = 0;
            for (let i = minIndex; i <= maxIndex; i++) {
                if (dataArray[i] > maxVolume) {
                    maxVolume = dataArray[i];
                    maxFrequency = i * nyquist / bufferLength;
                }
            }

            updateSoundVisualizations(dataArray, maxVolume, maxFrequency);
            requestAnimationFrame(detectSound);
        }

        function updateSoundVisualizations(dataArray, maxVolume, maxFrequency) {
            const volumeDB = maxVolume;
            
            visualizeFrequency(dataArray);
            visualizeVolume(volumeDB);
            updateVolumeDisplay(volumeDB);
            
            if (volumeDB > NOISE_THRESHOLD) {
                updateSoundStatus(volumeDB, maxFrequency);
            } else {
                updateSilenceStatus();
            }
            
            updateContinuityBuffer();
            visualizeContinuity();
        }

        function visualizeFrequency(dataArray) {
            frequencyCtx.fillStyle = 'rgb(200, 200, 200)';
            frequencyCtx.fillRect(0, 0, frequencyCanvas.width, frequencyCanvas.height);
            frequencyCtx.lineWidth = 2;
            frequencyCtx.strokeStyle = 'rgb(0, 0, 0)';
            frequencyCtx.beginPath();

            const sliceWidth = frequencyCanvas.width * 1.0 / dataArray.length;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const v = (dataArray[i] + 140) / 140;
                const y = v * frequencyCanvas.height / 2;

                if (i === 0) {
                    frequencyCtx.moveTo(x, y);
                } else {
                    frequencyCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            frequencyCtx.lineTo(frequencyCanvas.width, frequencyCanvas.height / 2);
            frequencyCtx.stroke();
        }

        function visualizeVolume(volume) {
            volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
            volumeCtx.fillStyle = 'rgb(0, 255, 0)';
            const height = (volume + 140) * volumeCanvas.height / 140;
            volumeCtx.fillRect(0, volumeCanvas.height - height, volumeCanvas.width, height);
        }

        function visualizeContinuity() {
            continuityCtx.fillStyle = 'rgb(200, 200, 200)';
            continuityCtx.fillRect(0, 0, continuityCanvas.width, continuityCanvas.height);
            
            const barWidth = continuityCanvas.width / continuityBuffer.length;
            continuityCtx.fillStyle = 'rgb(0, 0, 0)';
            
            for (let i = 0; i < continuityBuffer.length; i++) {
                const barHeight = continuityBuffer[i] * continuityCanvas.height;
                continuityCtx.fillRect(
                    i * barWidth,
                    continuityCanvas.height - barHeight,
                    barWidth,
                    barHeight
                );
            }
        }

        function updateVolumeDisplay(volumeDB) {
            volumeDisplay.textContent = `当前音量: ${volumeDB.toFixed(2)} dB`;
        }

        function updateSoundStatus(volumeDB, maxFrequency) {
            if (volumeDB > VOLUME_THRESHOLD) {
                status.textContent = '检测到人声';
                frequencyDisplay.textContent = `主要频率: ${maxFrequency.toFixed(2)} Hz`;
                
                const now = performance.now();
                const timeSinceLastVoice = now - lastVoiceDetectionTime;
                lastVoiceDetectionTime = now;

                continuityDisplay.textContent = timeSinceLastVoice < CONTINUITY_THRESHOLD ?
                    '语音连续性: 连续' : '语音连续性: 断续';
            } else {
                updateSilenceStatus();
            }
        }

        function updateSilenceStatus() {
            status.textContent = '未检测到人声';
            frequencyDisplay.textContent = '主要频率: - Hz';
            continuityDisplay.textContent = '语音连续性: -';
        }

        function updateContinuityBuffer() {
            const now = performance.now();
            const timeSinceLastVoice = now - lastVoiceDetectionTime;
            continuityBuffer.push(timeSinceLastVoice < CONTINUITY_THRESHOLD ? 1 : 0);
            continuityBuffer.shift();
        }

        function updateQueueStatus(status) {
            if (status) {
                document.getElementById('queue-size').textContent = status.queue_size;
                document.getElementById('total-processed').textContent = status.total_processed;
                
                // 更新进度条
                const progress = status.queue_size > 0 
                    ? (status.current_index / status.queue_size) * 100 
                    : 0;
                document.getElementById('process-progress').style.width = `${progress}%`;
            }
        }

        function clearResults() {
            transcriptionBuffer = '';
            translationBuffer = '';
            document.getElementById('transcription').textContent = '';
            document.getElementById('translation').textContent = '';
            document.getElementById('corrected-text').textContent = '';
            console.log('Cleared all results');
        }

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            // 3秒后自动隐藏误信息
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 3000);
        }

        // Graph updates
        socket.on('graph_update', (data) => {
            console.log('Received graph update:', data);
            const graphImg = document.getElementById('logic-graph');
            const statusDiv = document.getElementById('graph-status');
            const currentStatus = document.getElementById('current-status');
            const errorMessage = document.getElementById('error-message-graph');
            const lastUpdateTime = document.getElementById('last-update-time');
            
            if (data.image_data) {
                graphImg.src = data.image_data;
                graphImg.style.display = 'block';
                statusDiv.textContent = '图表已更新';
                currentStatus.textContent = '更新成功';
                errorMessage.textContent = '';
                lastUpdateTime.textContent = new Date().toLocaleTimeString();
            } else if (data.status) {
                statusDiv.textContent = data.status;
                currentStatus.textContent = data.status;
            } else if (data.error) {
                statusDiv.textContent = '图表生成失败';
                currentStatus.textContent = '生成失败';
                errorMessage.textContent = data.error;
                console.error('Graph generation error:', data.error);
            }
        });

        // Initialize Canvas sizes
        function initializeCanvasSizes() {
            const canvases = [frequencyCanvas, continuityCanvas, volumeCanvas];
            canvases.forEach(canvas => {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = 150;
            });
        }

        // Handle window resize
        window.addEventListener('resize', initializeCanvasSizes);
        
        // Initialize on load
        window.addEventListener('load', initializeCanvasSizes);

        // 添加连接状态调试
        socket.on('connect', () => {
            console.log('Socket connected with ID:', socket.id);
            document.getElementById('connection-status').textContent = '已连接 (ID: ' + socket.id + ')';
        });

        socket.on('error', (error) => {
            console.error('Socket error:', error);
            document.getElementById('error-message').textContent = '连接错误: ' + error;
            document.getElementById('error-message').style.display = 'block';
        });

        socket.on('disconnect', (reason) => {
            console.log('Socket disconnected:', reason);
            document.getElementById('connection-status').textContent = '已断开 (原因: ' + reason + ')';
        });

        // 添加详细的转写结果处理调试
        socket.on('transcription_result', (data) => {
            console.log('收到转写结果:', JSON.stringify(data, null, 2));
            
            if (data.result) {
                const transcriptionDiv = document.getElementById('transcription');
                const translationDiv = document.getElementById('translation');
                const correctedDiv = document.getElementById('corrected-text');
                
                console.log('转写文本:', data.result.transcription);
                console.log('翻译文本:', data.result.translation);
                console.log('修正文本:', data.result.corrected_text);
                
                try {
                    // 更新转写文本
                    if (data.result.transcription) {
                        transcriptionBuffer += data.result.transcription + '\n';
                        console.log('更新转写缓冲区:', transcriptionBuffer);
                        transcriptionDiv.innerHTML = transcriptionBuffer
                            .split('\n')
                            .filter(line => line.trim())
                            .map(line => `<p>${line}</p>`)
                            .join('');
                    }
                    
                    // 更新翻译文本
                    if (data.result.translation) {
                        translationBuffer += data.result.translation + '\n';
                        console.log('更新译缓冲区:', translationBuffer);
                        translationDiv.innerHTML = translationBuffer
                            .split('\n')
                            .filter(line => line.trim())
                            .map(line => `<p>${line}</p>`)
                            .join('');
                    }
                    
                    // 更新修正文本
                    if (data.result.corrected_text) {
                        console.log('更新修正文本:', data.result.corrected_text);
                        correctedDiv.innerHTML = `<p>${data.result.corrected_text}</p>`;
                    }
                } catch (error) {
                    console.error('处理转写结果时出错:', error);
                    document.getElementById('error-message').textContent = '处理错误: ' + error.message;
                    document.getElementById('error-message').style.display = 'block';
                }
            }
        });

        // 添加处理状态更新调试
        socket.on('processing_status', (data) => {
            console.log('处理状态更新:', data);
            updateQueueStatus(data);
        });

        // 添加错误处理调试
        socket.on('processing_error', (data) => {
            console.error('处理错误:', data);
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = `处理错误: ${data.error}`;
            errorDiv.style.display = 'block';
        });

        // 添加连接状态监控
        socket.on('connect', () => {
            console.log('Socket connected with ID:', socket.id);
            document.getElementById('connection-status').textContent = '已连接 (ID: ' + socket.id + ')';
        });

        socket.on('disconnect', (reason) => {
            console.log('Socket disconnected:', reason);
            document.getElementById('connection-status').textContent = '已断开 (原因: ' + reason + ')';
        });

        // 处理实时文本更新
        socket.on('text_update', (data) => {
            console.log('Received text update:', data);
            
            try {
                if (data.type === 'transcription') {
                    const transcriptionDiv = document.getElementById('transcription');
                    transcriptionBuffer += data.text + '\n';
                    transcriptionDiv.innerHTML = transcriptionBuffer
                        .split('\n')
                        .filter(line => line.trim())
                        .map(line => `<p>${line}</p>`)
                        .join('');
                    transcriptionDiv.scrollTop = transcriptionDiv.scrollHeight;
                }
                
                if (data.type === 'translation') {
                    const translationDiv = document.getElementById('translation');
                    translationBuffer += data.text + '\n';
                    translationDiv.innerHTML = translationBuffer
                        .split('\n')
                        .filter(line => line.trim())
                        .map(line => `<p>${line}</p>`)
                        .join('');
                    translationDiv.scrollTop = translationDiv.scrollHeight;
                }
            } catch (error) {
                console.error('Error processing text update:', error);
                document.getElementById('error-message').textContent = '处理错误: ' + error.message;
                document.getElementById('error-message').style.display = 'block';
            }
        });

        // 处理完整的转写结果
        socket.on('transcription_result', (data) => {
            console.log('Received transcription result:', data);
            
            if (data.result && data.result.corrected_text) {
                try {
                    const correctedDiv = document.getElementById('corrected-text');
                    correctedDiv.innerHTML = `<p>${data.result.corrected_text}</p>`;
                    correctedDiv.scrollTop = correctedDiv.scrollHeight;
                } catch (error) {
                    console.error('Error processing corrected text:', error);
                    document.getElementById('error-message').textContent = '处理错误: ' + error.message;
                    document.getElementById('error-message').style.display = 'block';
                }
            }
            
            if (data.queue_status) {
                updateQueueStatus(data.queue_status);
            }
        });

        // 错误处理
        socket.on('processing_error', (data) => {
            console.error('Processing error:', data);
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = `处理错误: ${data.error}`;
            errorDiv.style.display = 'block';
        });

        // 状态元素的引用
        const statusElements = {
            connection: document.getElementById('connection-status'),
            transcription: document.getElementById('transcription'),
            translation: document.getElementById('translation'),
            error: document.getElementById('error-message')
        };

        // 连接状态处理
        socket.on('connect', () => {
            console.log('Socket connected with ID:', socket.id);
            if (statusElements.connection) {
                statusElements.connection.textContent = '已连接';
                statusElements.connection.style.color = 'green';
            }
        });

        socket.on('disconnect', (reason) => {
            console.log('Socket disconnected:', reason);
            if (statusElements.connection) {
                statusElements.connection.textContent = '已断开';
                statusElements.connection.style.color = 'red';
            }
            // 自动重连
            socket.connect();
        });

        // 转写结果处理
        socket.on('transcription_result', (data) => {
            console.log('Received transcription result:', data);
            
            if (data.result && data.result.transcription && statusElements.transcription) {
                const newText = data.result.transcription;
                
                // 添加新文本
                if (statusElements.transcription.textContent) {
                    statusElements.transcription.textContent += '\n' + newText;
                } else {
                    statusElements.transcription.textContent = newText;
                }
                
                // 自动滚动到底部
                statusElements.transcription.scrollTop = statusElements.transcription.scrollHeight;
            }
        });

        // 错误处理
        socket.on('error', (error) => {
            console.error('Socket error:', error);
            if (statusElements.error) {
                statusElements.error.textContent = '错误: ' + error;
                statusElements.error.style.display = 'block';
            }
        });

        // 心跳检测
        setInterval(() => {
            if (socket.connected) {
                socket.emit('ping');
            }
        }, 30000);

        // 添加重连逻辑
        socket.on('disconnect', (reason) => {
            console.log('Socket disconnected:', reason);
            showError('连接已断开，正在尝试重连...');
            
            // 更新连接状态
            if (statusElements.connection) {
                statusElements.connection.textContent = '已断开';
                statusElements.connection.style.color = 'red';
            }
            
            // 尝试重连
            setTimeout(() => {
                if (!socket.connected) {
                    socket.connect();
                }
            }, 1000);
        });

        // 添加状态更新监听
        socket.on('status_update', (status) => {
            console.log('收到状态更新:', status);
            try {
                const processingStatus = document.getElementById('processing-status');
                const queueSize = document.getElementById('queue-size');
                const totalProcessed = document.getElementById('total-processed');
                const progressBar = document.getElementById('process-progress');
                
                if (processingStatus) {
                    processingStatus.textContent = status.processing ? '处理中' : '无';
                }
                
                if (queueSize) {
                    queueSize.textContent = status.queue_size;
                }
                
                if (totalProcessed) {
                    totalProcessed.textContent = status.total_processed;
                }
                
                if (progressBar) {
                    const progress = status.queue_size > 0 
                        ? ((status.current_index / status.queue_size) * 100).toFixed(1)
                        : 0;
                    progressBar.style.width = `${progress}%`;
                }
            } catch (error) {
                console.error('更新状态时出错:', error);
            }
        });
    </script>
</body>
</html>